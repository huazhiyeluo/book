{"./":{"url":"./","title":"前言","keywords":"","body":"空着，没想好写什么…… "},"db/db.html":{"url":"db/db.html","title":"1. 数据库篇","keywords":"","body":"1. memcached 安装 配置说明 命令 2. redis 安装 配置说明 命令 3. mongodb 安装 配置说明 命令 4. sqlite3 安装 配置说明 命令 5. mysql 安装 配置说明 命令 "},"db/memcached.html":{"url":"db/memcached.html","title":"1.1 memcached","keywords":"","body":"1. 安装 wget http://memcached.org/latest 下载最新版本tar -zxvf memcached-1.x.x.tar.gz 解压源码cd memcached-1.x.x 进入目录./configure --prefix=/usr/local/memcached 配置make && make test 编译sudo make install 安装 2. 配置说明 启动方式： /usr/local/bin/memcached -d -m 1024 -u root -l 127.0.0.1 -p 11211 -c 1024 -P /tmp/memcached.pid -d 是启动一个守护进程； -m 是分配给Memcache使用的内存数量，单位是MB； -u 是运行Memcache的用户； -l 是监听的服务器IP地址，可以有多个地址； -p 是设置Memcache监听的端口，，最好是1024以上的端口； -c 是最大运行的并发连接数，默认是1024； -P 是设置保存Memcache的pid文件。访问方式：telnet IP PORT 3. 命令 1.设置命令 1、set：如果set的key已经存在，该命令可以更新该key所对应的原来的数据，也就是实现更新的作用。 set key flags exptime bytes [noreply] value 2、add：如果 add 的 key 已经存在，则不会更新数据(过期的 key 会更新)，之前的值将仍然保持相同，并且您将获得响应 NOT_STORED。 add key flags exptime bytes [noreply] value 3、replace：如果 key 不存在，则替换失败，并且您将获得响应 NOT_STORED。 replace key flags exptime bytes [noreply] value 4、append：Memcached append 命令用于向已存在 key(键) 的 value(数据值) 后面追加数据 。 append key flags exptime bytes [noreply] value 5、prepend：Memcached prepend 命令用于向已存在 key(键) 的 value(数据值) 前面追加数据 。 prepend key flags exptime bytes [noreply] value 6、cas：Memcached CAS（Check-And-Set 或 Compare-And-Swap） 命令用于执行一个\"检查并设置\"的操作.它仅在当前客户端最后一次取值后，该key 对应的值没有被其他客户端修改的情况下， 才能够将值写入。检查是通过cas_token参数进行的， 这个参数是Memcach指定给已经存在的元素的一个唯一的64位值。 cas key flags exptime bytes unique_cas_token [noreply] value cas tp 0 900 9 ERROR #缺少 token cas tp 0 900 9 2 memcached NOT_FOUND #键 tp 不存在 set tp 0 900 9 memcached STORED gets tp VALUE tp 0 9 1 memcached END cas tp 0 900 5 1 redis STORED get tp VALUE tp 0 5 redis END 参数说明如下： key：键值 key-value 结构中的 key，用于查找缓存值。 flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 。 exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远） bytes：在缓存中存储的字节数 unique_cas_token通过 gets 命令获取的一个唯一的64位值。 noreply（可选）： 该参数告知服务器不需要返回数据 value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value） 2.查找命令 1、get：Memcached get 命令获取存储在 key(键) 中的 value(数据值) ，如果 key 不存在，则返回空。 get key get key1 key2 key3 2、gets：Memcached gets 命令获取带有 CAS 令牌存 的 value(数据值) ，如果 key 不存在，则返回空。 gets key gets key1 key2 key3 3、delete：Memcached delete 命令用于删除已存在的 key(键)。 delete key [noreply] 4、incr/decr：Memcached incr 与 decr 命令用于对已存在的 key(键) 的数字值进行自增或自减操作。incr 与 decr 命令操作的数据必须是十进制的32位无符号整数。如果 key 不存在返回 NOT_FOUND，如果键的值不为数字，则返回 CLIENT_ERROR，其他错误返回 ERROR。 append key flags exptime bytes [noreply] value 3.统计命令 1、stats：Memcached stats 命令用于返回统计信息例如 PID(进程号)、版本号、连接数等。 stats 2、stats items：Memcached stats items 命令用于显示各个 slab 中 item 的数目和存储时长(最后一次访问距离现在的秒数)。 stats items 3、stats slabs：Memcached stats slabs 命令用于显示各个slab的信息，包括chunk的大小、数目、使用情况等。 stats slabs 4、stats sizes：Memcached stats sizes 命令用于显示所有item的大小和个数。该信息返回两列，第一列是 item 的大小，第二列是 item 的个数。 stats sizes 5、flush_all：Memcached flush_all 命令用于清理缓存中的所有 key=>value(键=>值) 对。该命令提供了一个可选参数 time，用于在制定的时间后执行清理缓存操作。 flush_all [time] [noreply] 6、stats detail [on|off|dump]：设置或者显示详细操作记录 stats detail [on|off|dump] 7、stats cachedump slab_id limit_num：显示某个slab中的前limit_num个key列表. stats cachedump 7 2 8、stats reset：清空统计数据 stats reset 4.其他信息 1、统计信息（stats） 参数 值 描述 pid 1700 memcache服务器进程ID uptime 5335604 服务器已运行秒数 time 1557036895 服务器当前Unix时间戳 version 1.5.10 memcache版本 libevent 2.0.21-stable libevent版本 pointer_size 64 操作系统指针大小 rusage_user 805.137191 进程累计用户时间 rusage_system 460.201782 进程累计系统时间 max_connections 256 curr_connections 3 当前连接数量 total_connections 7742 Memcached运行以来连接总数 rejected_connections 0 connection_structures 5 Memcached分配的连接结构数量 reserved_fds 20 内部使用的FD数 cmd_get 6977 get命令请求次数 cmd_set 193 set命令请求次数 cmd_flush 0 flush命令请求次数 cmd_touch 0 touch命令请求次数 get_hits 6767 get命令命中次数 get_misses 210 get命令未命中次数 get_expired 1 get_flushed 0 delete_misses 4 delete命令未命中次数 delete_hits 4 delete命令命中次数 incr_misses 0 incr命令未命中次数 incr_hits 0 incr命令命中次数 decr_misses 0 decr命令未命中次数 decr_hits 0 decr命令命中次数 cas_misses 0 cas命令未命中次数 cas_hits 0 cas命令命中次数 cas_badval 0 使用擦拭次数 touch_hits 0 touch命令命中次数 touch_misses 0 touch命令未命中次数 auth_cmds 0 认证命令处理的次数 auth_errors 0 认证失败数目 bytes_read 9227571 读取总字节数 bytes_written 63626954 发送总字节数 limit_maxbytes 67108864 分配的内存总大小（字节） accepting_conns 1 接受新的连接 listen_disabled_num 0 失效的监听数 time_in_listen_disabled_us 0 threads 4 当前线程数 conn_yields 0 连接操作主动放弃数目 hash_power_level 16 hash表等级 hash_bytes 524288 当前hash表大小 hash_is_expanding 0 hash表正在扩展 slab_reassign_rescues 0 slab_reassign_chunk_rescues 0 slab_reassign_evictions_nomem 0 slab_reassign_inline_reclaim 0 slab_reassign_busy_items 0 slab_reassign_busy_deletes 0 slab_reassign_running 0 slabs_moved 0 lru_crawler_running 0 lru_crawler_starts 384795 lru_maintainer_juggles 32123450 malloc_fails 0 log_worker_dropped 0 log_worker_written 0 log_watcher_skipped 0 log_watcher_sent 0 bytes 1714945 当前存储占用的字节数 curr_items 6 当前存储的数据总数 total_items 193 启动以来存储的数据总数 slab_global_page_pool 0 expired_unfetched 9 已过期但未获取的对象数目 evicted_unfetched 0 已驱逐但未获取的对象数目 evicted_active 0 evictions 0 LRU释放的对象数目 reclaimed 171 已过期的数据条目来存储新数据的数目 crawler_reclaimed 1 crawler_items_checked 6406 lrutail_reflocked 3584 moves_to_cold 6295 moves_to_warm 6104 moves_within_lru 258 direct_reclaims 0 lru_bumps_dropped 0 2、区块信息（stats slabs） 参数 值 描述 active_slabs 10 slab数量 total_malloced 11534336 总内存数量 选择内存区块：SLAB : 1 参数 值 描述 chunk_size 96 chunk大小（byte） chunks_per_page 10922 每个page的chunk数量 total_pages 1 page数量 total_chunks 10922 chunk总数量（chunks_per_page*total_pages） used_chunks 0 已被分配的chunk数量 free_chunks 10922 过期数据空出的chunk数 free_chunks_end 0 从未被使用过的chunk数 mem_requested 0 请求存储的字节数 get_hits 2 get命令命中数 cmd_set 2 set命令请求数 delete_hits 0 delete命令命中数 incr_hits 0 incr命令命中数 decr_hits 0 decr命令命中数 cas_hits 0 cas命令命中数 cas_badval 0 cas数据类型错误数 touch_hits 0 touch命令命中数 3、ITEMS信息（stats items） 参数 值 描述 number 1 该slab中对象数（不包含过期对象） number_hot 0 number_warm 0 number_cold 1 age_hot 0 age_warm 0 age 284 LRU队列中最老对象的过期时间 evicted 0 LRU释放对象数 evicted_nonzero 0 设置了非0时间的LRU释放对象数 evicted_time 0 最后一次LRU释放的对象存在时间 outofmemory 0 不能存储对象次数 tailrepairs 0 修复slabs次数 reclaimed 35 使用过期对象空间存储对象次数 expired_unfetched 0 已过期但未获取的对象数目 evicted_unfetched 0 已驱逐但未获取的对象数目 evicted_active 0 crawler_reclaimed 0 crawler_items_checked 850 lrutail_reflocked 484 moves_to_cold 1004 moves_to_warm 968 moves_within_lru 15 direct_reclaims 0 hits_to_hot 1 hits_to_warm 19 hits_to_cold 1012 hits_to_temp 0 "},"db/redis.html":{"url":"db/redis.html","title":"1.2 redis","keywords":"","body":"1. 安装 wget http://download.redis.io/releases/redis-5.0.4.tar.gz 下载最新版本tar -zxvf redis-5.0.4.tar.gz 解压源码cd redis-5.0.4 进入目录make 配置 2. 配置说明 启动方式： ./redis-server ../redis.conf redis.conf 配置文件 daemonize no Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程 pidfile /var/run/redis.pid 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定 port 6379 指定Redis监听端口，默认端口为6379 bind 127.0.0.1 绑定的主机地址 timeout 300 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能 loglevel verbose 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose logfile stdout 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null databases 16 设置数据库的数量，默认数据库为0，可以使用SELECT 命令在连接上指定数据库id save 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合， save 900 1，save 300 10，save 60 10000 ，分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。 rdbcompression yes 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大 dbfilename dump.rdb 指定本地数据库文件名，默认值为dump.rdb dir ./ 指定本地数据库存放目录 slaveof 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步 masterauth 当master服务设置了密码保护时，slav服务连接master的密码 requirepass foobared 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH 命令提供密码，默认关闭 maxclients 128 设置同一时间最大客户端连接数，默认无限制 maxmemory 指定Redis最大内存限制 appendonly no 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no appendfilename appendonly.aof 指定更新日志文件名，默认为appendonly.aof appendfsync everysec 指定更新日志条件，共有3个可选值：no：表示等操作系统进行数据缓存同步到磁盘（快），always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全） ，everysec：表示每秒同步一次（折中，默认值） vm-enabled no 指定是否启用虚拟内存机制，默认值为no， vm-swap-file /tmp/redis.swap 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享 vm-max-memory 0 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0 vm-page-size 32 Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值 vm-pages 134217728 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。 vm-max-threads 4 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4 glueoutputbuf yes 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启 hash-max-zipmap-entries 64、hash-max-zipmap-value 512 activerehashing yes 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法 include /path/to/local.conf 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件 访问方式：redis-cli -h 192.168.1.27 -p 6379关闭服务：redis-cli shutdown 3. 数据类型介绍 基本类型：字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets）范围查询类型： bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询 二进制安全的字符串 Lists: 按插入顺序排序的字符串元素的集合。他们基本上就是链表（linked lists）。 Sets: 不重复且无序的字符串元素的集合。 Sorted sets,类似Sets,但是每个字符串元素都关联到一个叫score浮动数值（floating number value）。里面的元素总是通过score进行着排序，所以不同的是，它是可以检索的一系列元素。（例如你可能会问：给我前面10个或者后面10个元素）。 Hashes,由field和关联的value组成的map。field和value都是字符串的。这和Ruby、Python的hashes很像。 Bit arrays (或者说 simply bitmaps): 通过特殊的命令，你可以将 String 值当作一系列 bits 处理：可以设置和清除单独的 bits，数出所有设为 1 的 bits 的数量，找到最前的被设为 1 或 0 的 bit，等等。 HyperLogLogs: 这是被用于估计一个 set 中元素数量的概率性的数据结构。 3. 命令 1.键（key） 1、del：如果set的key已经存在，该命令可以更新该key所对应的原来的数据，也就是实现更新的作用。 DEL key [key ...] 2、dump：序列化给定 key ，并返回被序列化的值，使用 RESTORE 命令可以将这个值反序列化为 Redis 键。 DUMP key 3、restore：反序列化给定的序列化值，并将它和给定的 key 关联。 RESTORE key ttl \"\\x00\\x04liao\\t\\x00\\xb4\\xa8\\xbb\\xf1\\x01C\\x1b\\xf6\" 4、exists：返回key是否存在。1 如果key存在,0 如果key不存在 EXISTS key [key ...] 5、keys：查找所有符合给定模式pattern（正则表达式）的 key 。 KEYS pattern 6、expire（pexpire 毫秒）：设置key的过期时间，超过时间后，将会自动删除该key。在Redis的术语中一个key的相关超时是不确定的。1 如果成功设置过期时间。0 如果key不存在或者不能设置过期时间。 EXPIRE key 10 7、expireat（pexpireat 毫秒）: 的作用和 EXPIRE类似，都用于为 key 设置生存时间。不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳 Unix timestamp 。 EXPIREAT key 1293840000 8、migrate: 将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。 migrate ip port key | destination-db timeout [copy] [replace] [keys key] 9、move: 将当前数据库的 key 移动到给定的数据库 db 当中。如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key ，或者 key 不存在于当前数据库，那么 MOVE 没有任何效果。移动成功返回 1，失败则返回 0 move key db、move name 2 10、object: OBJECT 命令可以在内部调试(debugging)给出keys的内部对象，它用于检查或者了解你的keys是否用到了特殊编码 的数据类型来存储空间z。 当redis作为缓存使用的时候，你的应用也可能用到这些由OBJECT命令提供的信息来决定应用层的key的驱逐策略(eviction policies) OBJECT subcommand [arguments [arguments ...]] lpush mylist \"Hello World\" object refcount mylist object encoding mylist object idletime mylist OBJECT 命令可以在内部调试(debugging)给出keys的内部对象，它用于检查或者了解你的keys是否用到了特殊编码 的数据类型来存储空间z。 当redis作为缓存使用的时候，你的应用也可能用到这些由OBJECT命令提供的信息来决定应用层的key的驱逐策略(eviction policies) OBJECT ENCODING 该命令返回指定key对应value所使用的内部表示(representation)(译者注：也可以理解为数据的压缩方式). OBJECT IDLETIME 该命令返回指定key对应的value自被存储之后空闲的时间，以秒为单位(没有读写操作的请求) ，这个值返回以10秒为单位的秒级别时间，这一点可能在以后的实现中改善 11、persist: 移除给定key的生存时间，将这个 key 从『易失的』(带生存时间 key )转换成『持久的』(一个不带生存时间、永不过期的 key )。 SET mykey \"Hello\" EXPIRE mykey 10 TTL mykey PERSIST mykey TTL mykey 12、ttl（pttl 毫秒）: 返回key剩余的过期时间 TTL mykey 13、randomkey: 从当前数据库返回一个随机的key。 randomkey 14、rename: 将key重命名为newkey，如果key与newkey相同，将返回一个错误。如果newkey已经存在，则值将被覆盖。 RENAME mykey myotherkey 15、renamenx: 当且仅当 newkey 不存在时，将 key 改名为 newkey 。当 key 不存在时，返回一个错误。 RENAMENX mykey myotherkey 16、scan: 它们每次执行都只会返回少量元素，所以这些命令可以用于生产环境，而不会出现像 KEYS 或者 SMEMBERS 命令带来的可能会阻塞服务器的问题。 SCAN cursor [MATCH pattern] [COUNT count] 17、touch: 修改指定key(s) 最后访问时间 若key不存在，不做操作 TOUCH key [key ...] 18、unlink：该命令和DEL十分相似：删除指定的key(s),若key不存在则该key被跳过。但是，相比DEL会产生阻塞，该命令会在另一个线程中回收内存，因此它是非阻塞的。 这也是该命令名字的由来：仅将keys从keyspace元数据中删除，真正的删除会在后续异步操作。 UNLINK key [key ...] 2.字符串（string） 1、append：如果 key 已经存在，并且值为字符串，那么这个命令会把 value 追加到原来值（value）的结尾。 如果 key 不存在，那么它将首先创建一个空字符串的key，再执行追加操作，这种情况 APPEND 将类似于 SET 操作。返回append后字符串值（value）的长度。 APPEND key value 2、bitcount：统计字符串被设置为1的bit数. BITCOUNT key [start end] 3、decr/incr：对key对应的数字做减1操作。如果key不存在，那么在操作之前，这个key对应的值会被置为0。如果key有一个错误类型的value或者是一个不能表示成数字的字符串，就返回错误。这个操作最大支持在64位有符号的整型数字。 DECR key 4、decrby/incrby：将key对应的数字减decrement。如果key不存在，操作之前，key就会被置为0。如果key的value类型错误或者是个不能表示成数字的字符串，就返回错误。这个操作最多支持64位有符号的正型数字。 DECRBY mykey 5/DECRBY mykey 5 5、get：返回key的value。如果key不存在，返回特殊值nil。如果key的value不是string，就返回错误，因为GET只处理string类型的values。 GET mykey 6、getbit：返回key对应的string在offset处的bit值 当offset超出了字符串长度的时候，这个字符串就被假定为由0比特填充的连续空间. GETBIT mykey 100 7、getrange：这个命令是被改成GETRANGE的，在小于2.0的Redis版本中叫SUBSTR。 返回key对应的字符串value的子串，这个子串是由start和end位移决定的（两者都在string内）。可以用负的位移来表示从string尾部开始数的下标。所以-1就是最后一个字符，-2就是倒数第二个，以此类推。 GETRANGE key start end 8、getset：自动将key对应到value并且返回原来key对应的value。如果key存在但是对应的value不是字符串，就返回错误。返回之前的旧值，如果之前Key不存在将返回nil。 INCR mycounter GETSET mycounter \"0\" GET mycounter 9、mget：返回所有指定的key的value。对于每个不对应string或者不存在的key，都返回特殊值nil。正因为此，这个操作从来不会失败。 MGET key1 key2 nonexisting 10、mset：对应给定的keys到他们相应的values上。MSET会用新的value替换已经存在的value，就像普通的SET命令一样。如果你不想覆盖已经存在的values，请参看命令MSETNX。 MSET key1 \"Hello\" key2 \"World\" 11、msetnx：对应给定的keys到他们相应的values上。只要有一个key已经存在，MSETNX一个操作都不会执行。 由于这种特性，MSETNX可以实现要么所有的操作都成功，要么一个都不执行，这样可以用来设置不同的key，来表示一个唯一的对象的不同字段。 MSETNX key1 \"Hello\" key2 \"there\" 12、set：将键key设定为指定的“字符串”值。如果key已经保存了一个值，那么这个操作会直接覆盖原来的值，并且忽略原始类型。当set命令执行成功之后，之前设置的过期时间都将失效 SET key value [EX seconds] [PX milliseconds] [NX|XX] set phone xiaomi ex 50 13、setbit：设置或者清空key的value(字符串)在offset处的bit值。 SETBIT mykey 7 1 14、setex：设置key对应字符串value，并且设置key在给定的seconds时间之后超时过期。这个命令等效于执行下面的命令： SET mykey value EXPIRE mykey seconds SETEX mykey 10 \"Hello\" 3.列表（list） 1、blpop/brpop：当没有元素的时候会弹出一个 nil 的多批量值，并且 timeout 过期。当有元素弹出时会返回一个双元素的多批量值，其中第一个元素是弹出元素的 key，第二个元素是 value。 BLPOP key [key ...] timeout 2、brpoplpush/rpoplpush：Redis Brpoplpush 命令从列表中取出最后一个元素，并插入到另外一个列表的头部； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。 BRPOPLPUSH msg reciver 500/BRPOPLPUSH LIST1 ANOTHER_LIST TIMEOUT 3、lindex：返回列表里的元素的索引 index 存储在 key 里面。 下标是从0开始索引的，所以 0 是表示第一个元素， 1 表示第二个元素，并以此类推。 负数索引用于指定从列表尾部开始索引的元素。在这种方法下，-1 表示最后一个元素，-2 表示倒数第二个元素，并以此往前推。 LINDEX mylist 0 4、linsert：把 value 插入存于 key 的列表中在基准值 pivot 的前面或后面。当 key 不存在时，这个list会被看作是空list，任何操作都不会发生。当 key 存在，但保存的不是一个list的时候，会返回error。 RPUSH mylist \"Hello\" (integer) 1 RPUSH mylist \"World\" (integer) 2 LINSERT mylist BEFORE \"World\" \"There\" (integer) 3 LRANGE mylist 0 -1 1) \"Hello\" 2) \"There\" 3) \"World\" 5、llen：返回存储在 key 里的list的长度。 如果 key 不存在，那么就被看作是空list，并且返回长度为 0。 当存储在 key 里的值不是一个list的话，会返回error。 LLEN mylist 其他命令： 1、LPOP key 移除并且返回 key 对应的 list 的第一个元素。 2、LPUSH key value [value ...] 将所有指定的值插入到存于 key 的列表的头部。如果 key 不存在，那么在进行 push 操作前会创建一个空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。 3、LPUSHX key value 只有当 key 已经存在并且存着一个 list 的时候，在这个 key 下面的 list 的头部插入 value。 与 LPUSH 相反，当 key 不存在的时候不会进行任何操作。 4、LRANGE key start stop 返回存储在 key 的列表里指定范围内的元素。 start 和 end 偏移量都是基于0的下标，即list的第一个元素下标是0（list的表头），第二个元素下标是1，以此类推。 5、LREM key count value 从存于 key 的列表里移除前 count 次出现的值为 value 的元素。 这个 count 参数通过下面几种方式影响这个操作：count > 0: 从头往尾移除值为 value 的元素。count count = 0: 移除所有值为 value 的元素 6、LSET key index value 设置 index 位置的list元素的值为 value。 7、LTRIM key start stop 修剪(trim)一个已存在的 list，这样 list 就会只包含指定范围的指定元素。start 和 stop 都是由0开始计数的， 这里的 0 是列表里的第一个元素（表头），1 是第二个元素，以此类推。 8、RPOP key 移除并返回存于 key 的 list 的最后一个元素。 9、RPUSH key value [value ...] 向存于 key 的列表的尾部插入所有指定的值。如果 key 不存在，那么会创建一个空的列表然后再进行 push 操作。 当 key 保存的不是一个列表，那么会返回一个错误。 10、RPUSHX key value 将值 value 插入到列表 key 的表尾, 当且仅当 key 存在并且是一个列表。 和 RPUSH 命令相反, 当 key 不存在时，RPUSHX 命令什么也不做。 3.哈希（hash） 1、hdel：从 key 指定的哈希集中移除指定的域。在哈希集中不存在的域将被忽略。如果 key 指定的哈希集不存在，它将被认为是一个空的哈希集，该命令将返回0。 HDEL key field [field ...] 2、hexists：返回hash里面field是否存在 HEXISTS myhash field2 3、hget：返回 key 指定的哈希集中该字段所关联的值 HGET key field 4、hgetall：返回 key 指定的哈希集中所有的字段和值。 HGETALL myhash 5、hincrby/hincrbyfloat：增加 key 指定的哈希集中指定字段的数值。如果 key 不存在，会创建一个新的哈希集并与 key 关联。如果字段不存在，则字段的值在该操作执行前被设置为 0 HINCRBY 支持的值的范围限定在 64位 有符号整数 HINCRBY key field increment hincrby people age 1 6、hkeys：返回 key 指定的哈希集中所有字段的名字。 HKEYS key 7、hlen：返回 key 指定的哈希集包含的字段的数量。 HLEN key 8、hmget：返回 key 指定的哈希集中指定字段的值。 HMGET key field [field ...] 9、hmset：设置 key 指定的哈希集中指定字段的值。该命令将重写所有在哈希集中存在的字段。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联 HMSET key field value [field value ...] 10、hset：设置 key 指定的哈希集中指定字段的值。 HSET key field value 11、hsetnx：只在 key 指定的哈希集中不存在指定的字段时，设置字段的值。如果 key 指定的哈希集不存在，会创建一个新的哈希集并与 key 关联。如果字段已存在，该操作无效果。 HSETNX key field value 12、hstrlen：返回hash指定field的value的字符串长度，如果hash或者field不存在，返回0. HSTRLEN key field 13、hvals：返回 key 指定的哈希集中所有字段的值。 HVALS key 4.集合（set） 1、sadd：添加一个或多个指定的member元素到集合的 key中.指定的一个或者多个元素member 如果已经在集合key中存在则忽略.如果集合key 不存在，则新建集合key,并添加member元素到集合key中. SADD key member [member ...] 2、scard：返回集合存储的key的基数 (集合元素的数量). SCARD key 3、sdiff：返回一个集合与给定集合的差集的元素. SDIFF key [key ...] 4、sdiffstore：该命令类似于 SDIFF, 不同之处在于该命令不返回结果集，而是将结果存放在destination集合中. 如果destination已经存在, 则将其覆盖重写. SDIFFSTORE destination key [key ...] 5、sinter：返回指定所有的集合的成员的交集. SINTER key [key ...] 6、sinterstore：这个命令与SINTER命令类似, 但是它并不是直接返回结果集,而是将结果保存在 destination集合中. SINTERSTORE destination key [key ...] 7、sismember：返回成员 member 是否是存储的集合 key的成员. SISMEMBER key member 8、smembers：返回key集合所有的元素.该命令的作用与使用一个参数的SINTER 命令作用相同. SMEMBERS key 9、smove：将member从source集合移动到destination集合中. 对于其他的客户端,在特定的时间元素将会作为source或者destination集合的成员出现. SMOVE source destination member SMOVE myset myotherset \"two\" 10、spop：从存储在key的集合中移除并返回一个或多个随机元素。此操作与SRANDMEMBER类似，它从一个集合中返回一个或多个随机元素，但不删除元素。 SPOP key [count] 11、srandmember：那么随机返回key集合中的一个元素. SRANDMEMBER key [count] 12、srem：在key集合中移除指定的元素. 如果指定的元素不是key集合中的元素则忽略 如果key集合不存在则被视为一个空的集合，该命令返回0. SREM key member [member ...] 13、sunion：返回给定的多个集合的并集中的所有成员. SUNION key [key ...] 14、sunionstore：该命令作用类似于SUNION命令,不同的是它并不返回结果集,而是将结果存储在destination集合中.如果destination 已经存在,则将其覆盖. SUNIONSTORE destination key [key ...] 4.有序集合（sorted set） 1、zadd：将所有指定成员添加到键为key有序集合（sorted set）里面。 添加时可以指定多个分数/成员（score/member）对。 如果指定添加的成员已经是有序集合里面的成员，则会更新改成员的分数（scrore）并更新到正确的排序位置。 ZADD key [NX|XX] [CH] [INCR] score member [score member ...] 2、zcard：返回key的有序集元素个数。 ZCARD key 3、zcount：指定分数范围的元素个数。 ZCOUNT key min max 4、zincrby：为有序集key的成员member的score值加上增量increment。如果key中不存在member，就在key中添加一个member，score是increment（就好像它之前的score是0.0）。如果key不存在，就创建一个只含有指定member成员的有序集合 ZINCRBY key increment member 5、zintestore：计算给定的numkeys个有序集合的交集，并且把结果放到destination中。 在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。 ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight] [SUM|MIN|MAX] redis> ZADD zset1 1 \"one\" (integer) 1 redis> ZADD zset1 2 \"two\" (integer) 1 redis> ZADD zset2 1 \"one\" (integer) 1 redis> ZADD zset2 2 \"two\" (integer) 1 redis> ZADD zset2 3 \"three\" (integer) 1 redis> ZINTERSTORE out 2 zset1 zset2 WEIGHTS 2 3 (integer) 2 redis> ZRANGE out 0 -1 WITHSCORES 1) \"one\" 2) \"5\" 3) \"two\" 4) \"10\" 6、zpopmax：删除并返回有序集合key中的最多count个具有最高得分的成员。 ZPOPMAX key [count] 7、zpopmin：删除并返回有序集合key中的最多count个具有最低得分的成员。 ZPOPMIN key [count] 8、zrange：返回存储在有序集合key中的指定范围的元素。 ZRANGE key start stop [WITHSCORES] 8、zrevrange：返回存储在有序集合key中的指定范围的元素。其中成员的位置按score值递减(从大到小)来排列。 ZREVRANGE key start stop [WITHSCORES] 9、zrank：返回有序集key中成员member的排名。 ZRANK key member 10、zrevrank：返回有序集key中成员member的排名，其中有序集成员按score值从大到小排列。排名以0为底，也就是说，score值最大的成员排名为0。 ZREVRANK key member 11、zrem：返回的是从有序集合中删除的成员个数，不包括不存在的成员。 ZREM key member [member ...] 4、大量数据插入 data.txt文件 SET Key0 Value0 SET Key1 Value1 ... SET KeyN ValueN cat data.txt | redis-cli -h localhost -p 6380 -a liao --pipe unix2dos d1.txt 转码 cat d1.txt | redis-cli -h localhost -p 6380 -a liao [ --pipe ] "},"db/mongodb.html":{"url":"db/mongodb.html","title":"1.3 mongodb","keywords":"","body":"空着，待写…… "},"db/sqlite3.html":{"url":"db/sqlite3.html","title":"1.4 sqlite3","keywords":"","body":"空着，待写…… "},"db/mysql.html":{"url":"db/mysql.html","title":"1.5 mysql","keywords":"","body":"空着，待写…… "},"php/php.html":{"url":"php/php.html","title":"2. PHP篇","keywords":"","body":"空着，待写…… "},"php/base.html":{"url":"php/base.html","title":"1.1 基础语法","keywords":"","body":"空着，待写…… "},"php/ext.html":{"url":"php/ext.html","title":"1.2 扩展库","keywords":"","body":"空着，待写…… "},"php/example.html":{"url":"php/example.html","title":"1.3 实战案例","keywords":"","body":"空着，待写…… "},"python/python.html":{"url":"python/python.html","title":"3. Python篇","keywords":"","body":"空着，待写…… "},"python/base.html":{"url":"python/base.html","title":"1.1 基础语法","keywords":"","body":"空着，待写…… "},"python/ext.html":{"url":"python/ext.html","title":"1.2 扩展库","keywords":"","body":"空着，待写…… "},"python/example.html":{"url":"python/example.html","title":"1.3 实战案例","keywords":"","body":"空着，待写…… "},"common/preface.html":{"url":"common/preface.html","title":"尾声","keywords":"","body":"有些情，只能止于唇齿，掩于岁月 卷首引：从此天涯陌路，天各一方。 从此互不来往，斩断情愫。 删除了记忆，清空了珍藏。 不再徘徊在彷徨的路上。 不再泪水央央度过夜的漫长。 崭新的一天湛蓝， 轻装上阵的舒畅。 风送来你的剪影， 搅乱了愁怀萦肠，望着你离开时走的那条路，蹲下身子，久久的看着，看着，直到细雨飘摇，直到天幕落下，直到无声的哽咽。 不知道这世上，还有多少人，能与你和我一般，初遇时便禁不住心动，仿佛认识了很久，我们是那么的相似，连说话的语气，处事的方式也是这么的相像，好像是遇见了另一个自己，明明还是那么陌生，却熟悉的像是老朋友。 越相似，越了解，也越明白对方，似乎能将彼此看透，知道你的心中带着的伤，想要走近，想要安抚，想要带着清风明月，为你黯然的生活，带去新的面貌。 你也知道我怀揣着的远方和过往，和未来的路将会走向何方，却只愿面对现在，绝口不提以后，也似乎还沉浸在，那些本该尘封的旧年月里。 明晰了彼此内心深处的所想，懂得了各自的固执和坚持，即便有些话不说出口，也知道分开的时候到了。我们之间是这样的了解，连告别也不再需要，只需要默契的不再联系，不再约定晨昏之时相伴，不再述说这一天，这许多天发生过什么事，看过什么值得一笑的话。 如果还有什么迷惑的话，那便是我不知道，我们之间算是什么，是爱，是吸引，或者只是有缘相伴一程，想了很久，也想不出这究竟是怎样的一种情感，姑且称它为情。 一日又一日过去，拉开了当初的距离，从熟悉到更熟悉，从更熟悉再到陌生，原来忘却只需要不再提起，人海之中的似曾相识，是一切开始的源头。似曾相识的源头，是有着相同的过去，有着同样不能忘怀的人，执拗的不肯放下，我们之间一步之遥的距离，便成了天涯海角的隔阂。 我们这样的一段情，只能止于唇齿，你这样的一个人，只能掩于岁月。不知道在失去的时候，那是一种什么样的感觉，有些酸涩，有些不甘，有些遗憾，却又深知，这一切是必然。遇见后相互牵引，是必然，相互深深的懂得，是必然，懂得之后放手，也是必然。 曾为这样的一个人，写过这样的一首《尘心》：情人滴泪夜娑婆，万花盛放饰人间，一树一叶尽尘缘，满目空待山河远。从相遇到相离，万花盛放到秋叶凋零，所有的期待成空，所有的向往变成了尘缘里的妄想。 于是慢慢的忘却，没有错，是忘却，将他丢在风里，斩断了情丝，重新过回一个人的日子。因为找到一个彼此懂得的人，是曾经最为的期待的爱情，遇到了这样的人，却只能分离，便需要忘记，让爱消失在记忆消失前。 止于唇齿，掩于岁月。 "}}